与第一部分（SQL编译器）的链接

1.执行计划接口对接
// 在StorageEngine中预留的接口，用于接收SQL编译器的执行计划
public class StorageEngine {
    // 这些方法可以直接被SQL编译器生成的执行计划调用
public Page getPage(int pageId);   
// 对应 read_page(page_id)
public boolean writePage(int pageId, byte[] data); 
// 对应 write_page(page_id,data)
public Page allocateNewPage(int[] pageId); 
// 用于CREATE TABLE操作
}

2. 执行算子支持
// 需要扩展StorageEngine以支持SQL执行算子
public class SQLExecutor {
    // CreateTable算子 -> 调用StorageEngine.allocateNewPage()
    // Insert算子 -> 调用StorageEngine.writeRecordToPage()
    // SeqScan算子 -> 调用StorageEngine.getPage() 遍历所有页面
    // Filter算子 -> 在内存中过滤页面数据
    // Project算子 -> 在内存中投影指定列
}

与第三部分（数据库系统）的链接

3. 系统目录管理
// 需要添加系统目录管理
public class SystemCatalog {
    private StorageEngine storageEngine;
    
    // 系统目录作为特殊表存储
    public void createTable(String tableName, List<Column> columns) {
        // 1. 在系统目录中注册表元数据
        // 2. 调用StorageEngine分配页面存储表数据
    }
    
    public TableSchema getTableSchema(String tableName) {
        // 从系统目录中读取表结构信息
    }
}

4.记录与页面的映射
// 需要实现记录序列化/反序列化
public class RecordManager {
    private StorageEngine storageEngine;
    
    // 将记录序列化到页面
    public boolean insertRecord(String tableName, Record record) {
        // 1. 找到合适的页面
        // 2. 将记录序列化到页面
        // 3. 更新页面元数据
    }
    
    // 从页面反序列化记录
    public List<Record> selectRecords(String tableName, Condition condition) {
        // 1. 遍历表的所有页面
        // 2. 反序列化记录
        // 3. 应用过滤条件
    }
}
