**===== Page 1 =====**
中南大学
CENTRAL SOUTH UNIVERSITY

《大型平台软件设计实习》

计算机学院
姚鑫、邓磊、桂宁

------

**===== Page 2 =====**
简化版数据库系统实现

**SQL编译器**

- 词法分析：识别关键字、标识符、常量、运算符
- 语法分析：构建语法树，支持四类语句
- 语义分析：存在性、类型、列数检查
- 执行计划生成：转换为逻辑执行计划

**存储系统**

- 页式存储：支持页分配、释放、读写
- 缓存机制：LRU/FIFO 策略，命中统计与日志
- 提供接口供数据库模块调用

**数据库引擎**

- 执行引擎：支持 CreateTable、Insert、SeqScan、Filter、Project
- 存储引擎：实现行与页的映射、磁盘组织
- 系统目录：维护元数据，作为特殊表存储

可以不支持事务、并发控制、复杂索引、查询优化、访问控制等高级功能。

------

**===== Page 3 =====**
MySQL体系架构

- 客户端连接器
  Native C API, JDBC, ODBC, .NET, PHP, Perl, Python, Ruby, Cobol
- MySQL Server
  - 系统管理和控制工具
    Backup & Recovery, Security, Replication, Cluster, Administration, Configuration, Migration, Metadata
  - 连接池
    Authentication, Thread Reuse, Connection Limits, Check Memory, Caches
  - SQL接口
    DMI, DDI, Stored Procedures, Views, Triggers, etc
  - 解析器
    Query Translation, Object Privilege
  - 查询优化器
    Access Paths, Statistics
  - 缓存
    Global and Engine Specific Caches & Buffers
  - 可插拔存储引擎
    Memory, Index & Storage Management
    MyISAM, InnoDB, NDB, Archive, Federated, Memory, Merge, Partner, Community, Custom
- 系统文件
  NTFS, ufs, ext2/3, NFS, SAN, NAS
- 文件和日志
  Redo, Undo, Data, Index, Binary, Error, Query and Slow

------

**===== Page 4 =====**
数据库中的数据存储

数据库存储通常分为两层：

- **逻辑存储结构**：这是程序员和用户看到的视角，比如表、行、列、索引。
- **物理存储结构**：这是数据在磁盘上实际存储的格式，比如文件、块、页、数据区。

数据库管理系统（DBMS）的核心工作之一就是在逻辑结构和物理结构之间进行转换和管理。

------

**===== Page 5 =====**

# 逻辑存储结构（用户眼中的数据库）

- **数据库** (Database)：一个容器，包含所有相关的数据对象。
- **表** (Table)：存储数据的主要单位，由行和列组成。
- **行** (Row) / 记录 (Record)：代表一个实体或一条完整的数据。
- **列** (Column) / 字段 (Field)：代表实体的一个属性。
- **索引** (Index)：一种特殊的数据结构，用于快速查找数据，类似于书目的目录。

------

**===== Page 6 =====**

# 物理存储结构（磁盘上的真实面貌）

- 数据最终必须存储在磁盘上（或SSD）。其基本组织单位是页（Page）或块（Block）。
- **核心概念**: 页 (Page)
  - **是什么**：页是数据库磁盘I/O操作的最小单位。
  - **大小**：通常是4KB, 8KB, 16KB等（例如MySQL InnoDB默认是16KB）。
  - **页里面有什么**：
    - **页头** (Header)：存储元信息，如页号、指针、类型、剩余空间等。
    - **行数据** (Rows)：实际的数据记录。
    - **槽** (Slots)：指针数组，指向页内的行数据。

------

**===== Page 7 =====**

# 数据文件如何组织？

- 数据库通常会创建一个或多个物理文件（如 mydb.ibd）。这些文件被划分为多个区（Extent）。
- **区（Extent）**：由多个连续的页组成（例如，InnoDB中1个区 = 64个页 = 1MB）。
- 表数据存储：
  - 一个表的数据可能存放在一个单独的表空间（Tablespace）中，也可能与其他表共享。
  - **表空间（Tablespace）**：一个逻辑概念，代表一个或多个物理数据文件的集合。
  - 数据行被有序或无序地存储在数据页中。多个数据页通过双向链表连接起来。

------

**===== Page 8 =====**

# 一条记录是如何被写入？

1. 应用程序发出 INSERT 语句。
2. DBMS解析SQL，找到目标表和要插入的数据。
3. DBMS找到合适的数据页来存放新记录。
4. 如果该页在缓冲池中，直接修改；否则从磁盘加载。
5. 将新记录写入页的空闲空间，更新页头、槽等信息。
6. 更新所有相关索引（B+树），可能引发索引页分裂。
7. 脏页在适当时机（Checkpoint）刷回磁盘。

------

**===== Page 9 =====**

# 一条记录是如何被读取的？

1. 应用程序发出 SELECT 语句。
2. 查询优化器决定使用哪个索引或全表扫描。
3. 使用索引（B+树）：
   - 从根节点开始，逐层向下查找，直到叶子节点。
   - 如果是聚簇索引，叶子节点就是数据页；否则需回表查询。
4. 将找到的数据页（若不在缓冲池则从磁盘加载）返回给应用程序。

------

**===== Page 10 =====**

# 一条SQL语句执行过程

1. 连接器 (Connector)：管理连接，权限认证。
2. 解析器 (Parser)：将SQL翻译成解析树。
3. 分析器/预处理器 (Analyzer / Preprocessor)：解析语义，检查权限。
4. 优化器 (Optimizer)：选择最佳执行计划。
5. 执行器 (Executor)：调用存储引擎接口执行查询。
6. 存储引擎 (Storage Engine)：负责数据的存储和提取。

------

**===== Page 11 =====**

# 索引存储（极其重要！）

- 绝大多数现代关系型数据库使用 B+树 (B+Tree) 作为索引结构。
- B+树的特点：
  - 所有叶子节点位于同一层，包含所有数据（或指针）。
  - 叶子节点之间通过指针相连，形成双向链表，适合范围查询。
- 存储体现：
  - 非叶子节点：存储在索引页中，包含键值和指向子节点的指针。
  - 叶子节点：聚簇索引包含行数据，非聚簇索引包含主键值。

------

**===== Page 12 =====**

# B+树

图例：

- 非叶子节点：10, 20, 30, 41
- 叶子节点：1,2,5,12,18,23,25,27,33,35

B+树的特点：

- 数据只出现在叶子节点
- 所有叶子节点增加了一个键指针
- 直接遍历叶子链表，极高效
- 适用于关系型数据库索引、大数据存储
- 优势：范围查询、磁盘友好、更高的填充率，适合顺序扫描

------

**===== Page 13 =====**

# 数据库包含哪些文件？如：MySQL (InnoDB)

1. **数据文件**
   - ibdata1：系统表空间文件，存储数据字典、undo日志等
   - 表名.ibd：每张表的独立表空间文件（启用 innodb_file_per_table 时）
2. **日志文件**
   - 重做日志 (Redo Log)：ib_logfile0, ib_logfile1
   - 撤销日志 (Undo Log)：用于事务回滚和MVCC
3. **控制文件**
   - 存储数据库的物理结构信息和状态，极其关键
4. **配置文件**
   - my.cnf (Linux) 或 my.ini (Windows)

------

**===== Page 14 =====**

# 元数据如何存储？

- 元数据以“表”的形式存在，称为系统表或数据字典表。
- 执行 SHOW TABLES; 或查询 INFORMATION_SCHEMA 时，实际是在查询这些系统表。
- MySQL 的元数据存储在系统表空间（ibdata1）和 mysql 系统数据库中。

------

**===== Page 15 =====**

# 数据库的存储总结

- 数据存储在固定大小的页中。
- 表和数据通过表空间文件管理。
- 索引使用B+树结构，由页构成，加速查询。
- 缓冲池（内存）协调CPU与磁盘速度差异。
- 逻辑上的“行”映射到物理上的“页”，通过B+树、LRU等算法保证一致性、持久性和高性能。

------

**===== Page 16 =====**
分阶段实现：

- 先实现SQL编译器（词法分析、语法分析、语义分析）
- 然后实现存储系统（页式存储、缓存管理）
- 最后实现数据库引擎（执行器、存储引擎）

------

**===== Page 17 =====**
（与第2页内容相同）

------

**===== Page 18 =====**

# 项目结构建议

text

```
database_system/
├── sql_complier/    # SQL编译器模块
│   ├── lexer.py    # 词法分析器
│   ├── parser.py    # 语法分析器
│   ├── semantic.py    # 语义分析器
│   ├── planner.py    # 执行计划生成器
│   └── catalog.py    # 模式目录管理
├── storage/    # 存储系统模块
│   ├── page.py    # 页式存储实现
│   ├── buffer.py    # 缓存管理实现
│   └── file_manager.py  # 文件管理
├── engine/    # 数据库引擎模块
│   ├── executor.py    # 执行引擎
│   ├── storage_engine.py  # 存储引擎
│   └── catalog_manager.py  # 系统目录管理
├── cli/    # 命令行接口
│   └── main.py    # 主程序入口
├── tests/    # 测试文件
│   ├── test_sql.py    # SQL编译器测试
│   ├── test_storage.py  # 存储系统测试
│   └── test_db.py    # 数据库系统测试
└── utils/    # 工具函数
    ├── constants.py    # 常量定义
    └── helpers.py    # 辅助函数
```



------

**===== Page 19 =====**
示例代码框架

python

```
# main.py - 一个极简的DBMS CLI
from storage_engine import StorageEngine
from parser import SQLParser

class SimpleDBMS:
    def __init__(self):
        self.storage = StorageEngine()
        self.parser = SQLParser()

    def execute(self, sql_text):
        ast = self.parser.parse(sql_text)
        if ast['type'] == 'create_table':
            return self.storage.create_table(ast['table_name'], ast['columns'])
        elif ast['type'] == 'insert':
            return self.storage.insert(ast['table_name'], ast['values'])
        elif ast['type'] == 'select':
            return self.storage.full_table_scan(ast['table_name'], ast['where'])
        else:
            raise Exception(f"Unsupported SQL type: {ast['type']}")

if __name__ == '__main__':
    db = SimpleDBMS()
    while True:
        try:
            sql = input("MiniDB > ")
            if sql.lower() == 'quit':
                break
            result = db.execute(sql)
            print(result)
        except Exception as e:
            print(f"Error: {e}")
```



------

**===== Page 20 =====**
示例代码框架

python

```
# storage_engine.py - 存储引擎雏形
import struct

class StorageEngine:
    def __init__(self, data_dir='data/'):
        self.data_dir = data_dir
        self.tables_meta = {}  # 缓存表结构
        self.buffer_pool = {}  # 缓冲区

    def create_table(self, name, columns):
        print(f"Creating table {name} with columns {columns}")
        return "OK"

    def insert(self, table_name, values):
        print(f"Inserting into {table_name}: {values}")
        return "1 row inserted"

    def full_table_scan(self, table_name, where_clause):
        print(f"Scanning table {table_name} where {where_clause}")
        return [["dummy_row_id", "dummy_value_1", "dummy_value_2"]]
```