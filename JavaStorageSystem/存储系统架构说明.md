# 存储系统架构说明

## 🏗️ 整体架构

```
数据库引擎层 (Database Engine)
        ↓ 调用
存储引擎层 (StorageEngine) ← 你负责的部分
        ↓ 委托给
缓冲池管理器 (BufferPoolManager)
        ↓ 委托给
磁盘管理器 (DiskManager)
        ↓ 操作
磁盘文件 (.db文件)
```

## 📁 持久化文件位置

根据你的测试结果，持久化文件都在 `E:\SQL实训\JavaStorageSystem\` 目录下：

- `test_db.db` (16KB) - 基本操作测试数据库
- `test_cache.db` (60KB) - 缓存测试数据库  
- `test_concurrent.db` (36KB) - 并发测试数据库
- `test_table.db` (12KB) - 表页操作测试数据库
- `test_persist.db` (12KB) - 持久化测试数据库
- `test_fifo.db` (60KB) - FIFO策略测试数据库
- `debug.db` (4KB) - 调试测试数据库
- `index_comparison_test.db` (3.5MB) - 索引对比测试数据库

## 🔄 调用流程详解

### 1. 数据库引擎如何调用你的存储系统

```java
// 数据库引擎创建存储引擎实例
StorageEngine storageEngine = new StorageEngine(10, "database.db", ReplacementPolicy.LRU);

// 数据库引擎调用存储引擎的方法
Page page = storageEngine.allocateNewPage(pageId);  // 分配新页面
storageEngine.writeRecordToPage(pageId, "data");    // 写入数据
storageEngine.flushAllPages();                      // 刷新到磁盘
```

### 2. 存储引擎内部调用链

```java
StorageEngine.allocateNewPage()
    ↓ 委托给
BufferPoolManager.newPage()
    ↓ 如果需要从磁盘读取
DiskManager.readPage()
    ↓ 写入磁盘文件
database.db 文件
```

### 3. 数据持久化过程

#### 写入数据流程：
```
1. 数据库引擎调用: storageEngine.writeRecordToPage(pageId, data)
2. 存储引擎调用: bufferPoolManager.getPage(pageId)
3. 缓冲池管理器检查页面是否在内存中
4. 如果不在，从磁盘读取: diskManager.readPage(pageId, pageData)
5. 将数据写入页面: page.writeString(data)
6. 标记页面为脏页: releasePage(pageId, true)
7. 定期或显式刷新: bufferPoolManager.flushPage(pageId)
8. 磁盘管理器写入: diskManager.writePage(pageId, pageData)
9. 数据最终保存到 .db 文件
```

#### 读取数据流程：
```
1. 数据库引擎调用: storageEngine.getPage(pageId)
2. 存储引擎调用: bufferPoolManager.getPage(pageId)
3. 缓冲池管理器检查页面是否在内存中
4. 如果在内存中，直接返回 (缓存命中)
5. 如果不在内存中，从磁盘读取: diskManager.readPage(pageId, pageData)
6. 将页面加载到缓冲池中
7. 返回页面给数据库引擎
```

## 🗂️ 核心组件职责

### StorageEngine (存储引擎)
- **职责**: 对外提供统一接口，隐藏内部实现细节
- **主要方法**:
  - `allocateNewPage()` - 分配新页面
  - `getPage()` - 获取页面
  - `writeRecordToPage()` - 写入记录
  - `flushAllPages()` - 刷新所有页面到磁盘
  - `createIntegerIndex()` - 创建索引

### BufferPoolManager (缓冲池管理器)
- **职责**: 管理内存中的页面缓存，实现页面替换策略
- **主要功能**:
  - 页面缓存管理 (LRU/FIFO替换策略)
  - 页面分配和释放
  - 缓存命中率统计
  - 线程安全的并发访问

### DiskManager (磁盘管理器)
- **职责**: 负责页面的磁盘I/O操作
- **主要功能**:
  - 从磁盘读取页面
  - 将页面写入磁盘
  - 数据库文件的创建和管理
  - 文件锁机制保证并发安全

### Page (页面)
- **职责**: 表示4KB大小的数据页面
- **主要功能**:
  - 存储实际数据
  - 提供数据读写接口
  - 管理页面状态 (脏页、pin计数等)

## 💾 数据持久化机制

### 1. 页面大小
- 每个页面固定为 **4KB** (4096字节)
- 这是数据库系统的标准页面大小

### 2. 文件结构
```
database.db 文件结构:
┌─────────────┬─────────────┬─────────────┬─────────────┐
│   Page 0    │   Page 1    │   Page 2    │   Page 3    │
│  (4KB)      │  (4KB)      │  (4KB)      │  (4KB)      │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 3. 持久化时机
- **显式刷新**: 调用 `flushAllPages()` 或 `flushPage(pageId)`
- **隐式刷新**: 页面被替换出缓冲池时自动刷新
- **程序关闭**: 存储引擎关闭时自动刷新所有脏页

### 4. 脏页管理
- 页面被修改后标记为"脏页" (dirty)
- 只有脏页才会被写入磁盘
- 未修改的页面直接从内存返回，无需磁盘I/O

## 🔒 并发控制

### 1. 读写锁机制
- **读锁**: 多个线程可以同时读取页面
- **写锁**: 只有一个线程可以修改页面
- **可重入**: 同一线程可以多次获取锁

### 2. 页面锁定
- **Pin机制**: 页面被使用时增加pin计数
- **Unpin机制**: 页面使用完毕后减少pin计数
- **替换策略**: 只有pin计数为0的页面才能被替换

## 📊 性能优化

### 1. 缓存机制
- 内存中缓存常用页面，减少磁盘I/O
- 支持LRU和FIFO两种替换策略
- 缓存命中率统计和监控

### 2. 批量操作
- 支持批量刷新页面到磁盘
- 减少系统调用次数，提高性能

### 3. 预分配
- 页面预分配机制，减少运行时分配开销

## 🎯 与数据库引擎的接口

数据库引擎通过以下方式使用你的存储系统：

```java
// 1. 初始化存储引擎
StorageEngine engine = new StorageEngine(bufferSize, dbFile, policy);

// 2. 创建表 (分配页面)
int[] pageId = new int[1];
Page tablePage = engine.allocateTablePage(pageId);

// 3. 插入数据
engine.writeRecordToPage(pageId[0], "record data");

// 4. 查询数据
Page page = engine.getPage(pageId[0]);
String data = page.readString();

// 5. 创建索引
engine.createIntegerIndex("user_id_index", 10);
engine.insertToIndex("user_id_index", 123, pageId[0]);

// 6. 刷新数据到磁盘
engine.flushAllPages();

// 7. 关闭存储引擎
engine.close();
```

这就是你的存储系统如何被数据库引擎调用，以及数据如何持久化到磁盘文件的完整流程！
